<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>Offset</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Offset"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://ankbzpx.github.io/my-personal-knowledge-cache/notes/zbxdptxtbmmvoecg0ub5eyd/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="3/8/2022"/><meta property="article:modified_time" content="3/8/2022"/><link rel="canonical" href="https://ankbzpx.github.io/my-personal-knowledge-cache/notes/zbxdptxtbmmvoecg0ub5eyd/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/my-personal-knowledge-cache/_next/static/css/6db750d8aae1efab.css" as="style"/><link rel="stylesheet" href="/my-personal-knowledge-cache/_next/static/css/6db750d8aae1efab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/my-personal-knowledge-cache/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/my-personal-knowledge-cache/_next/static/chunks/webpack-14fc00b0a180680f.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/main-ced06fae44febf7d.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/pages/_app-7f0c0a28af6ee1f5.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/155-3a6c02d7e042edb7.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/373-9c38fabb487d5920.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/pages/notes/%5Bid%5D-b20175c77adb354a.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/ihOclfcI71GY0CxNfF2GS/_buildManifest.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/ihOclfcI71GY0CxNfF2GS/_ssgManifest.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/ihOclfcI71GY0CxNfF2GS/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout site-layout" style="margin-top:64px"><section class="ant-layout site-layout" style="flex-direction:row"><section class="ant-layout site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></section><section class="ant-layout side-layout-main" style="max-width:1200px;display:initial"><main class="ant-layout-content main-content" role="main" style="padding:0 24px"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="offset"><a aria-hidden="true" class="anchor-heading" href="#offset"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Offset</h1>
<h2 id="use-library"><a aria-hidden="true" class="anchor-heading" href="#use-library"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Use library</h2>
<p><a href="http://www.angusj.com/delphi/clipper.php">Clipper library</a>
(<a href="https://github.com/fonttools/pyclipper">python binding</a>)</p>
<blockquote>
<p>Clipper seems to return a densely sampled polygon</p>
</blockquote>
<h2 id="using-glu"><a aria-hidden="true" class="anchor-heading" href="#using-glu"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Using GLU</h2>
<blockquote>
<p>Algorithm reference: <a href="https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf">https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf</a></p>
</blockquote>
<blockquote>
<p>GLU reference chapter: <a href="https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/PolygonTessellation/PolygonTessellation.html">https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/PolygonTessellation/PolygonTessellation.html</a></p>
</blockquote>
<p>My implementation</p>
<pre><code># Only handles single polygon offset
# Algorithm: https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf
def polygon_edge_segments_offset(polygon, offset):
    vertex_start = polygon

    normalized = lambda x: x / (np.linalg.norm(x, axis=1) + 1e-10).reshape(
        -1, 1)

    def compute_edge_specs(edge_vector):
        edge_vector = np.insert(edge_vector, obj=2, values=0, axis=1)
        edge_vector_next = np.roll(edge_vector, -1, axis=0)
        # angle between two adjacent edges
        angles = np.arccos(-np.sum(edge_vector * edge_vector_next, axis=1) /
                           (np.linalg.norm(edge_vector, axis=1) *
                            np.linalg.norm(edge_vector_next, axis=1)) + 1e-10)
        # angle for arcs centered at shared vertices
        arc_angle = np.pi - angles
        # CCW, right concave, left convex
        is_convex = np.sign(np.cross(edge_vector, edge_vector_next)[:, -1]) > 0
        # CCW, toward right
        exterior_normal = np.cross(
            edge_vector,
            np.tile(np.array([0, 0, 1]), reps=(len(edge_vector), 1)))[:, :2]
        return arc_angle, is_convex, normalized(exterior_normal)

    vertex_end = np.roll(vertex_start, -1, axis=0)
    edge_segments = np.hstack((vertex_start, vertex_end)).reshape(-1, 2, 2)
    edge_vector = vertex_end - vertex_start
    arc_angle, is_convex, exterior_normal = compute_edge_specs(edge_vector)

    # Subdivide with a simple policy
    # Interval:    0   pi/8   3*pi/8
    # Subdivision:   |  0  |  2  |  4
    c1 = arc_angle > np.pi / 8
    c2 = arc_angle &#x3C; 3 * np.pi / 8

    with_arc = is_convex if np.sign(offset) > 0 else np.invert(is_convex)
    query_d1 = np.all([np.all([c1, c2], axis=0), with_arc], axis=0)
    query_d2 = np.all([np.invert(c2), with_arc], axis=0)

    # -1: use shared vertex
    #  0: direct connect
    #  1: divide once, then connect
    #  2: divide twice, then connect
    subdivide = np.zeros(len(query_d2))
    subdivide[np.invert(with_arc)] = -1
    subdivide[query_d1] = 1
    subdivide[query_d2] = 2

    offset_edge_segments = edge_segments + (offset * exterior_normal).reshape(
        -1, 1, 2)
    offset_vertex_start = offset_edge_segments[:, 0, :]
    offset_vertex_end = offset_edge_segments[:, 1, :]
    offset_vertex_start_next = np.roll(offset_vertex_start, -1, axis=0)

    def subdivision(left, right, centroid, radius, level):
        if level == 0:
            return []
        middle = radius * normalized(0.5 *
                                     (left + right) - centroid) + centroid
        return subdivision(left, middle, centroid, radius, level - 1) + [
            middle
        ] + subdivision(middle, right, centroid, radius, level - 1)

    arc_vertices = np.array(
        subdivision(offset_vertex_end, offset_vertex_start_next, vertex_end,
                    abs(offset), 2)).transpose([1, 0, 2])

    lift_once = lambda x: [y for y in x]
    lift_twice = lambda x: [lift_once(y) for y in x]

    def get_auxiliary_vertices(shared_vertices, auxiliary_vertices, level):
        if level == -1:
            return [shared_vertices]
        elif level == 0:
            return []
        elif level == 1:
            return [auxiliary_vertices[1]]
        elif level == 2:
            return lift_once(auxiliary_vertices)

    # no idea how to vectorize, use for loop instead
    auxiliary_vertices = [
        get_auxiliary_vertices(vertex_end[i], arc_vertices[i], subdivide[i])
        for i in range(len(subdivide))
    ]

    # edge vertices -> auxiliary vertices -> next edge vertices ...
    new_vertex_list = [[]] * 2 * len(subdivide)
    new_vertex_list[0::2] = lift_twice(offset_edge_segments)
    new_vertex_list[1::2] = auxiliary_vertices

    # Reference: https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-a-list-of-lists
    new_vertex_list_merged = list(
        itertools.chain.from_iterable(new_vertex_list))

    return new_vertex_list, new_vertex_list_merged


# Reference: https://www.glprogramming.com/red/chapter11.html
def get_positive_winding_polygon_boundary(polygon):

    polygon = np.array(polygon)
    if polygon.shape[1] == 2:
        polygon = np.insert(polygon, 2, 0, axis=1)

    boundary_polygons = []

    def glu_tess_begin_callback(type):
        global boundary_polygon
        boundary_polygon = []

    def glu_tess_vertex_callback(vertex_data):
        global boundary_polygon
        boundary_polygon.append(vertex_data[:2])

    def glu_tess_end_callback():
        global boundary_polygon
        boundary_polygons.append(boundary_polygon)

    def glu_tess_error_callback(errno):
        print("glu_tess_error_callback", GLU.gluErrorString(errno))

    def glu_tess_combine_callback(vertex,
                                  neighbors,
                                  neighborWeights,
                                  out=None):
        out = vertex[:3]
        return out

    tes = GLU.gluNewTess()
    GLU.gluTessCallback(tes, GLU.GLU_TESS_BEGIN, glu_tess_begin_callback)
    GLU.gluTessCallback(tes, GLU.GLU_TESS_VERTEX, glu_tess_vertex_callback)
    GLU.gluTessCallback(tes, GLU.GLU_TESS_END, glu_tess_end_callback)
    GLU.gluTessCallback(tes, GLU.GLU_TESS_ERROR, glu_tess_error_callback)
    GLU.gluTessCallback(tes, GLU.GLU_TESS_COMBINE, glu_tess_combine_callback)
    GLU.gluTessProperty(tes, GLU.GLU_TESS_BOUNDARY_ONLY, GL.GL_TRUE)
    GLU.gluTessProperty(tes, GLU.GLU_TESS_WINDING_RULE,
                        GLU.GLU_TESS_WINDING_POSITIVE)
    GLU.gluTessNormal(tes, 0, 0, 1)

    GLU.gluTessBeginPolygon(tes, None)
    GLU.gluTessBeginContour(tes)
    for vert in polygon:
        GLU.gluTessVertex(tes, vert, vert)
    GLU.gluTessEndContour(tes)
    GLU.gluTessEndPolygon(tes)
    GLU.gluDeleteTess(tes)

    return boundary_polygons


def polygon_offset(polygon, offset):
    _, edge_offset_polygon = polygon_edge_segments_offset(polygon, offset)
    return get_positive_winding_polygon_boundary(edge_offset_polygon)
</code></pre></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#use-library" title="Use library">Use library</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#using-glu" title="Using GLU">Using GLU</a></div></div></div></div></div></div></div></div></div></main><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></section></section></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"zbxdptxtbmmvoecg0ub5eyd","title":"Offset","desc":"","updated":1646726698246,"created":1646726636848,"custom":{},"fname":"polygon.offset","type":"note","vault":{"fsPath":"vault"},"contentHash":"faf7fda36ff7bf64931e80a4c096ef84","links":[],"anchors":{"use-library":{"type":"header","text":"Use library","value":"use-library","line":8,"column":0,"depth":2},"using-glu":{"type":"header","text":"Using GLU","value":"using-glu","line":14,"column":0,"depth":2}},"children":[],"parent":"npuhs4xvm0sa31rz2gcuff3","data":{}},"body":"\u003ch1 id=\"offset\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#offset\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eOffset\u003c/h1\u003e\n\u003ch2 id=\"use-library\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#use-library\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eUse library\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://www.angusj.com/delphi/clipper.php\"\u003eClipper library\u003c/a\u003e\n(\u003ca href=\"https://github.com/fonttools/pyclipper\"\u003epython binding\u003c/a\u003e)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eClipper seems to return a densely sampled polygon\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"using-glu\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#using-glu\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eUsing GLU\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAlgorithm reference: \u003ca href=\"https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf\"\u003ehttps://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGLU reference chapter: \u003ca href=\"https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/PolygonTessellation/PolygonTessellation.html\"\u003ehttps://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/PolygonTessellation/PolygonTessellation.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMy implementation\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Only handles single polygon offset\n# Algorithm: https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf\ndef polygon_edge_segments_offset(polygon, offset):\n    vertex_start = polygon\n\n    normalized = lambda x: x / (np.linalg.norm(x, axis=1) + 1e-10).reshape(\n        -1, 1)\n\n    def compute_edge_specs(edge_vector):\n        edge_vector = np.insert(edge_vector, obj=2, values=0, axis=1)\n        edge_vector_next = np.roll(edge_vector, -1, axis=0)\n        # angle between two adjacent edges\n        angles = np.arccos(-np.sum(edge_vector * edge_vector_next, axis=1) /\n                           (np.linalg.norm(edge_vector, axis=1) *\n                            np.linalg.norm(edge_vector_next, axis=1)) + 1e-10)\n        # angle for arcs centered at shared vertices\n        arc_angle = np.pi - angles\n        # CCW, right concave, left convex\n        is_convex = np.sign(np.cross(edge_vector, edge_vector_next)[:, -1]) \u003e 0\n        # CCW, toward right\n        exterior_normal = np.cross(\n            edge_vector,\n            np.tile(np.array([0, 0, 1]), reps=(len(edge_vector), 1)))[:, :2]\n        return arc_angle, is_convex, normalized(exterior_normal)\n\n    vertex_end = np.roll(vertex_start, -1, axis=0)\n    edge_segments = np.hstack((vertex_start, vertex_end)).reshape(-1, 2, 2)\n    edge_vector = vertex_end - vertex_start\n    arc_angle, is_convex, exterior_normal = compute_edge_specs(edge_vector)\n\n    # Subdivide with a simple policy\n    # Interval:    0   pi/8   3*pi/8\n    # Subdivision:   |  0  |  2  |  4\n    c1 = arc_angle \u003e np.pi / 8\n    c2 = arc_angle \u0026#x3C; 3 * np.pi / 8\n\n    with_arc = is_convex if np.sign(offset) \u003e 0 else np.invert(is_convex)\n    query_d1 = np.all([np.all([c1, c2], axis=0), with_arc], axis=0)\n    query_d2 = np.all([np.invert(c2), with_arc], axis=0)\n\n    # -1: use shared vertex\n    #  0: direct connect\n    #  1: divide once, then connect\n    #  2: divide twice, then connect\n    subdivide = np.zeros(len(query_d2))\n    subdivide[np.invert(with_arc)] = -1\n    subdivide[query_d1] = 1\n    subdivide[query_d2] = 2\n\n    offset_edge_segments = edge_segments + (offset * exterior_normal).reshape(\n        -1, 1, 2)\n    offset_vertex_start = offset_edge_segments[:, 0, :]\n    offset_vertex_end = offset_edge_segments[:, 1, :]\n    offset_vertex_start_next = np.roll(offset_vertex_start, -1, axis=0)\n\n    def subdivision(left, right, centroid, radius, level):\n        if level == 0:\n            return []\n        middle = radius * normalized(0.5 *\n                                     (left + right) - centroid) + centroid\n        return subdivision(left, middle, centroid, radius, level - 1) + [\n            middle\n        ] + subdivision(middle, right, centroid, radius, level - 1)\n\n    arc_vertices = np.array(\n        subdivision(offset_vertex_end, offset_vertex_start_next, vertex_end,\n                    abs(offset), 2)).transpose([1, 0, 2])\n\n    lift_once = lambda x: [y for y in x]\n    lift_twice = lambda x: [lift_once(y) for y in x]\n\n    def get_auxiliary_vertices(shared_vertices, auxiliary_vertices, level):\n        if level == -1:\n            return [shared_vertices]\n        elif level == 0:\n            return []\n        elif level == 1:\n            return [auxiliary_vertices[1]]\n        elif level == 2:\n            return lift_once(auxiliary_vertices)\n\n    # no idea how to vectorize, use for loop instead\n    auxiliary_vertices = [\n        get_auxiliary_vertices(vertex_end[i], arc_vertices[i], subdivide[i])\n        for i in range(len(subdivide))\n    ]\n\n    # edge vertices -\u003e auxiliary vertices -\u003e next edge vertices ...\n    new_vertex_list = [[]] * 2 * len(subdivide)\n    new_vertex_list[0::2] = lift_twice(offset_edge_segments)\n    new_vertex_list[1::2] = auxiliary_vertices\n\n    # Reference: https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-a-list-of-lists\n    new_vertex_list_merged = list(\n        itertools.chain.from_iterable(new_vertex_list))\n\n    return new_vertex_list, new_vertex_list_merged\n\n\n# Reference: https://www.glprogramming.com/red/chapter11.html\ndef get_positive_winding_polygon_boundary(polygon):\n\n    polygon = np.array(polygon)\n    if polygon.shape[1] == 2:\n        polygon = np.insert(polygon, 2, 0, axis=1)\n\n    boundary_polygons = []\n\n    def glu_tess_begin_callback(type):\n        global boundary_polygon\n        boundary_polygon = []\n\n    def glu_tess_vertex_callback(vertex_data):\n        global boundary_polygon\n        boundary_polygon.append(vertex_data[:2])\n\n    def glu_tess_end_callback():\n        global boundary_polygon\n        boundary_polygons.append(boundary_polygon)\n\n    def glu_tess_error_callback(errno):\n        print(\"glu_tess_error_callback\", GLU.gluErrorString(errno))\n\n    def glu_tess_combine_callback(vertex,\n                                  neighbors,\n                                  neighborWeights,\n                                  out=None):\n        out = vertex[:3]\n        return out\n\n    tes = GLU.gluNewTess()\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_BEGIN, glu_tess_begin_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_VERTEX, glu_tess_vertex_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_END, glu_tess_end_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_ERROR, glu_tess_error_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_COMBINE, glu_tess_combine_callback)\n    GLU.gluTessProperty(tes, GLU.GLU_TESS_BOUNDARY_ONLY, GL.GL_TRUE)\n    GLU.gluTessProperty(tes, GLU.GLU_TESS_WINDING_RULE,\n                        GLU.GLU_TESS_WINDING_POSITIVE)\n    GLU.gluTessNormal(tes, 0, 0, 1)\n\n    GLU.gluTessBeginPolygon(tes, None)\n    GLU.gluTessBeginContour(tes)\n    for vert in polygon:\n        GLU.gluTessVertex(tes, vert, vert)\n    GLU.gluTessEndContour(tes)\n    GLU.gluTessEndPolygon(tes)\n    GLU.gluDeleteTess(tes)\n\n    return boundary_polygons\n\n\ndef polygon_offset(polygon, offset):\n    _, edge_offset_polygon = polygon_edge_segments_offset(polygon, offset)\n    return get_positive_winding_polygon_boundary(edge_offset_polygon)\n\u003c/code\u003e\u003c/pre\u003e","noteIndex":{"id":"o3PkEany5FTDLokev2jkJ","title":"Root","desc":"","updated":1656832289330,"created":1640014633146,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"1f4a8dbd787743b10f24422968be02a9","links":[],"anchors":{"history":{"type":"header","text":"History","value":"history","line":10,"column":0,"depth":2},"disclaimer":{"type":"header","text":"Disclaimer","value":"disclaimer","line":15,"column":0,"depth":2}},"children":["Vn1Ykq4aIagi0bhZowkgD","ja5HFaIxVEtbZoTklNXfZ","vnzxfoqb6aqbrqy247uonqo","jjlv4wd30bvf0r680o9ptbi","kok8aerdrzko8v4i6w6qtjx","hr8ruqfxd2miwldyehzz5zy","criy8usqjrguecufwb3k8z2","3x9f9wclumzxc23dzgraepy","sma2hkp8hvq9urmtk94qqwq","4bcvwahaynsox941d8dimxw","8u19znq05xj50ptse0fq8nj","hbcft05imtwxxtwk52nij1n","2vmt81onv3jf06ejwfusj30","npuhs4xvm0sa31rz2gcuff3","mwt2mrjm58oa3q2osoqwd64","yjnf5fuac95jbdmjj923hyh","17p3nbv4rvga83hhsz2idzp","8r1egy8mz3lp7ud9p8kcg8z","5gf8xb68r1y0kxumkvvmuez","d92qhaqtfbt7e4eximdnbht","r25bm5nuug9krur6ddqearm"],"parent":null,"data":{},"body":"\nMy personal knowledge cache using [Dendron](https://www.dendron.so)\n\n## History\nIt was during my first job, at the start-up company called PixelShift.AI, that I acquired most prominent skill as a software engineer-the ability to read source code. It opened up a new way of learning and my knowledge expanded rapidly ever since. Learning new things is thriving but noting them down cogently and organized is hard. I often found myself forget the context few month later, making the notes completely intelligible. Additionally, some notes need frequent update as my previous understanding could be parochial, antiquated or even erroneous.\n\nIn desperate attempt to facilitate the noting/updating experience, I came across [Dendron](https://www.dendron.so) and found it surprisingly congenial to my personal need. With it, I have gradually grown the habit of caching, linking back and extending my knowledge base.\n\n## Disclaimer\nThe notes are collections of information I found along the journey. I use backquote to denote sources, but I am likely to miss some references, so apology in advance. Also, they are my personal understandings, usually added when I first encounter the topic and will be updated only when I come across it again, so some of them could be incomplete or wrong."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.86.1","enableFullHierarchyNoteTitle":false,"enableHandlebarTemplates":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"enableSiteLastModified":true,"siteRootDir":"docs","enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"writeStubs":false,"seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enablePrettyLinks":true,"assetsPrefix":"/my-personal-knowledge-cache","siteUrl":"https://ankbzpx.github.io","enableTaskNotes":true,"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"zbxdptxtbmmvoecg0ub5eyd"},"buildId":"ihOclfcI71GY0CxNfF2GS","assetPrefix":"/my-personal-knowledge-cache","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>