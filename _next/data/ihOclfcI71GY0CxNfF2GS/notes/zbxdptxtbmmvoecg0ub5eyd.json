{"pageProps":{"note":{"id":"zbxdptxtbmmvoecg0ub5eyd","title":"Offset","desc":"","updated":1646726698246,"created":1646726636848,"custom":{},"fname":"polygon.offset","type":"note","vault":{"fsPath":"vault"},"contentHash":"faf7fda36ff7bf64931e80a4c096ef84","links":[],"anchors":{"use-library":{"type":"header","text":"Use library","value":"use-library","line":8,"column":0,"depth":2},"using-glu":{"type":"header","text":"Using GLU","value":"using-glu","line":14,"column":0,"depth":2}},"children":[],"parent":"npuhs4xvm0sa31rz2gcuff3","data":{}},"body":"<h1 id=\"offset\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#offset\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Offset</h1>\n<h2 id=\"use-library\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#use-library\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Use library</h2>\n<p><a href=\"http://www.angusj.com/delphi/clipper.php\">Clipper library</a>\n(<a href=\"https://github.com/fonttools/pyclipper\">python binding</a>)</p>\n<blockquote>\n<p>Clipper seems to return a densely sampled polygon</p>\n</blockquote>\n<h2 id=\"using-glu\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#using-glu\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Using GLU</h2>\n<blockquote>\n<p>Algorithm reference: <a href=\"https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf\">https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf</a></p>\n</blockquote>\n<blockquote>\n<p>GLU reference chapter: <a href=\"https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/PolygonTessellation/PolygonTessellation.html\">https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/PolygonTessellation/PolygonTessellation.html</a></p>\n</blockquote>\n<p>My implementation</p>\n<pre><code># Only handles single polygon offset\n# Algorithm: https://mcmains.me.berkeley.edu/pubs/DAC05OffsetPolygon.pdf\ndef polygon_edge_segments_offset(polygon, offset):\n    vertex_start = polygon\n\n    normalized = lambda x: x / (np.linalg.norm(x, axis=1) + 1e-10).reshape(\n        -1, 1)\n\n    def compute_edge_specs(edge_vector):\n        edge_vector = np.insert(edge_vector, obj=2, values=0, axis=1)\n        edge_vector_next = np.roll(edge_vector, -1, axis=0)\n        # angle between two adjacent edges\n        angles = np.arccos(-np.sum(edge_vector * edge_vector_next, axis=1) /\n                           (np.linalg.norm(edge_vector, axis=1) *\n                            np.linalg.norm(edge_vector_next, axis=1)) + 1e-10)\n        # angle for arcs centered at shared vertices\n        arc_angle = np.pi - angles\n        # CCW, right concave, left convex\n        is_convex = np.sign(np.cross(edge_vector, edge_vector_next)[:, -1]) > 0\n        # CCW, toward right\n        exterior_normal = np.cross(\n            edge_vector,\n            np.tile(np.array([0, 0, 1]), reps=(len(edge_vector), 1)))[:, :2]\n        return arc_angle, is_convex, normalized(exterior_normal)\n\n    vertex_end = np.roll(vertex_start, -1, axis=0)\n    edge_segments = np.hstack((vertex_start, vertex_end)).reshape(-1, 2, 2)\n    edge_vector = vertex_end - vertex_start\n    arc_angle, is_convex, exterior_normal = compute_edge_specs(edge_vector)\n\n    # Subdivide with a simple policy\n    # Interval:    0   pi/8   3*pi/8\n    # Subdivision:   |  0  |  2  |  4\n    c1 = arc_angle > np.pi / 8\n    c2 = arc_angle &#x3C; 3 * np.pi / 8\n\n    with_arc = is_convex if np.sign(offset) > 0 else np.invert(is_convex)\n    query_d1 = np.all([np.all([c1, c2], axis=0), with_arc], axis=0)\n    query_d2 = np.all([np.invert(c2), with_arc], axis=0)\n\n    # -1: use shared vertex\n    #  0: direct connect\n    #  1: divide once, then connect\n    #  2: divide twice, then connect\n    subdivide = np.zeros(len(query_d2))\n    subdivide[np.invert(with_arc)] = -1\n    subdivide[query_d1] = 1\n    subdivide[query_d2] = 2\n\n    offset_edge_segments = edge_segments + (offset * exterior_normal).reshape(\n        -1, 1, 2)\n    offset_vertex_start = offset_edge_segments[:, 0, :]\n    offset_vertex_end = offset_edge_segments[:, 1, :]\n    offset_vertex_start_next = np.roll(offset_vertex_start, -1, axis=0)\n\n    def subdivision(left, right, centroid, radius, level):\n        if level == 0:\n            return []\n        middle = radius * normalized(0.5 *\n                                     (left + right) - centroid) + centroid\n        return subdivision(left, middle, centroid, radius, level - 1) + [\n            middle\n        ] + subdivision(middle, right, centroid, radius, level - 1)\n\n    arc_vertices = np.array(\n        subdivision(offset_vertex_end, offset_vertex_start_next, vertex_end,\n                    abs(offset), 2)).transpose([1, 0, 2])\n\n    lift_once = lambda x: [y for y in x]\n    lift_twice = lambda x: [lift_once(y) for y in x]\n\n    def get_auxiliary_vertices(shared_vertices, auxiliary_vertices, level):\n        if level == -1:\n            return [shared_vertices]\n        elif level == 0:\n            return []\n        elif level == 1:\n            return [auxiliary_vertices[1]]\n        elif level == 2:\n            return lift_once(auxiliary_vertices)\n\n    # no idea how to vectorize, use for loop instead\n    auxiliary_vertices = [\n        get_auxiliary_vertices(vertex_end[i], arc_vertices[i], subdivide[i])\n        for i in range(len(subdivide))\n    ]\n\n    # edge vertices -> auxiliary vertices -> next edge vertices ...\n    new_vertex_list = [[]] * 2 * len(subdivide)\n    new_vertex_list[0::2] = lift_twice(offset_edge_segments)\n    new_vertex_list[1::2] = auxiliary_vertices\n\n    # Reference: https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-a-list-of-lists\n    new_vertex_list_merged = list(\n        itertools.chain.from_iterable(new_vertex_list))\n\n    return new_vertex_list, new_vertex_list_merged\n\n\n# Reference: https://www.glprogramming.com/red/chapter11.html\ndef get_positive_winding_polygon_boundary(polygon):\n\n    polygon = np.array(polygon)\n    if polygon.shape[1] == 2:\n        polygon = np.insert(polygon, 2, 0, axis=1)\n\n    boundary_polygons = []\n\n    def glu_tess_begin_callback(type):\n        global boundary_polygon\n        boundary_polygon = []\n\n    def glu_tess_vertex_callback(vertex_data):\n        global boundary_polygon\n        boundary_polygon.append(vertex_data[:2])\n\n    def glu_tess_end_callback():\n        global boundary_polygon\n        boundary_polygons.append(boundary_polygon)\n\n    def glu_tess_error_callback(errno):\n        print(\"glu_tess_error_callback\", GLU.gluErrorString(errno))\n\n    def glu_tess_combine_callback(vertex,\n                                  neighbors,\n                                  neighborWeights,\n                                  out=None):\n        out = vertex[:3]\n        return out\n\n    tes = GLU.gluNewTess()\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_BEGIN, glu_tess_begin_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_VERTEX, glu_tess_vertex_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_END, glu_tess_end_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_ERROR, glu_tess_error_callback)\n    GLU.gluTessCallback(tes, GLU.GLU_TESS_COMBINE, glu_tess_combine_callback)\n    GLU.gluTessProperty(tes, GLU.GLU_TESS_BOUNDARY_ONLY, GL.GL_TRUE)\n    GLU.gluTessProperty(tes, GLU.GLU_TESS_WINDING_RULE,\n                        GLU.GLU_TESS_WINDING_POSITIVE)\n    GLU.gluTessNormal(tes, 0, 0, 1)\n\n    GLU.gluTessBeginPolygon(tes, None)\n    GLU.gluTessBeginContour(tes)\n    for vert in polygon:\n        GLU.gluTessVertex(tes, vert, vert)\n    GLU.gluTessEndContour(tes)\n    GLU.gluTessEndPolygon(tes)\n    GLU.gluDeleteTess(tes)\n\n    return boundary_polygons\n\n\ndef polygon_offset(polygon, offset):\n    _, edge_offset_polygon = polygon_edge_segments_offset(polygon, offset)\n    return get_positive_winding_polygon_boundary(edge_offset_polygon)\n</code></pre>","noteIndex":{"id":"o3PkEany5FTDLokev2jkJ","title":"Root","desc":"","updated":1656832289330,"created":1640014633146,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"1f4a8dbd787743b10f24422968be02a9","links":[],"anchors":{"history":{"type":"header","text":"History","value":"history","line":10,"column":0,"depth":2},"disclaimer":{"type":"header","text":"Disclaimer","value":"disclaimer","line":15,"column":0,"depth":2}},"children":["Vn1Ykq4aIagi0bhZowkgD","ja5HFaIxVEtbZoTklNXfZ","vnzxfoqb6aqbrqy247uonqo","jjlv4wd30bvf0r680o9ptbi","kok8aerdrzko8v4i6w6qtjx","hr8ruqfxd2miwldyehzz5zy","criy8usqjrguecufwb3k8z2","3x9f9wclumzxc23dzgraepy","sma2hkp8hvq9urmtk94qqwq","4bcvwahaynsox941d8dimxw","8u19znq05xj50ptse0fq8nj","hbcft05imtwxxtwk52nij1n","2vmt81onv3jf06ejwfusj30","npuhs4xvm0sa31rz2gcuff3","mwt2mrjm58oa3q2osoqwd64","yjnf5fuac95jbdmjj923hyh","17p3nbv4rvga83hhsz2idzp","8r1egy8mz3lp7ud9p8kcg8z","5gf8xb68r1y0kxumkvvmuez","d92qhaqtfbt7e4eximdnbht","r25bm5nuug9krur6ddqearm"],"parent":null,"data":{},"body":"\nMy personal knowledge cache using [Dendron](https://www.dendron.so)\n\n## History\nIt was during my first job, at the start-up company called PixelShift.AI, that I acquired most prominent skill as a software engineer-the ability to read source code. It opened up a new way of learning and my knowledge expanded rapidly ever since. Learning new things is thriving but noting them down cogently and organized is hard. I often found myself forget the context few month later, making the notes completely intelligible. Additionally, some notes need frequent update as my previous understanding could be parochial, antiquated or even erroneous.\n\nIn desperate attempt to facilitate the noting/updating experience, I came across [Dendron](https://www.dendron.so) and found it surprisingly congenial to my personal need. With it, I have gradually grown the habit of caching, linking back and extending my knowledge base.\n\n## Disclaimer\nThe notes are collections of information I found along the journey. I use backquote to denote sources, but I am likely to miss some references, so apology in advance. Also, they are my personal understandings, usually added when I first encounter the topic and will be updated only when I come across it again, so some of them could be incomplete or wrong."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.86.1","enableFullHierarchyNoteTitle":false,"enableHandlebarTemplates":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"enableSiteLastModified":true,"siteRootDir":"docs","enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"writeStubs":false,"seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enablePrettyLinks":true,"assetsPrefix":"/my-personal-knowledge-cache","siteUrl":"https://ankbzpx.github.io","enableTaskNotes":true,"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}