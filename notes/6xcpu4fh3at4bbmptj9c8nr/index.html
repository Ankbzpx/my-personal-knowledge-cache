<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>Connect Polygons with Their Offset Ones</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Connect Polygons with Their Offset Ones"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://ankbzpx.github.io/my-personal-knowledge-cache/notes/6xcpu4fh3at4bbmptj9c8nr/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="3/8/2022"/><meta property="article:modified_time" content="3/11/2022"/><link rel="canonical" href="https://ankbzpx.github.io/my-personal-knowledge-cache/notes/6xcpu4fh3at4bbmptj9c8nr/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/my-personal-knowledge-cache/_next/static/css/6db750d8aae1efab.css" as="style"/><link rel="stylesheet" href="/my-personal-knowledge-cache/_next/static/css/6db750d8aae1efab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/my-personal-knowledge-cache/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/my-personal-knowledge-cache/_next/static/chunks/webpack-14fc00b0a180680f.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/main-ced06fae44febf7d.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/pages/_app-7f0c0a28af6ee1f5.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/155-3a6c02d7e042edb7.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/373-9c38fabb487d5920.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/chunks/pages/notes/%5Bid%5D-b20175c77adb354a.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/ihOclfcI71GY0CxNfF2GS/_buildManifest.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/ihOclfcI71GY0CxNfF2GS/_ssgManifest.js" defer=""></script><script src="/my-personal-knowledge-cache/_next/static/ihOclfcI71GY0CxNfF2GS/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout site-layout" style="margin-top:64px"><section class="ant-layout site-layout" style="flex-direction:row"><section class="ant-layout site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></section><section class="ant-layout side-layout-main" style="max-width:1200px;display:initial"><main class="ant-layout-content main-content" role="main" style="padding:0 24px"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="connect-polygons-with-their-offset-ones"><a aria-hidden="true" class="anchor-heading" href="#connect-polygons-with-their-offset-ones"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Connect Polygons with Their Offset Ones</h1>
<h2 id="steps"><a aria-hidden="true" class="anchor-heading" href="#steps"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Steps:</h2>
<ol>
<li>Get list of edges for exterior and interior polygons</li>
<li>Force exterior to be CCW, interior to be CW</li>
<li>Apply delaunay triangulation</li>
<li>For each delaunay triangle, find the ones that do not intersect with exterior/interior polygons, append its non-polygon edges</li>
<li>Find all chordless cycles in undirected graph using wall-walking algorithm (ignore CW traversal of boundary edges)</li>
<li>Treat all chordless cycles as faces. For non-triangle faces, tessellated them if necessary</li>
</ol>
<h2 id="implementation"><a aria-hidden="true" class="anchor-heading" href="#implementation"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Implementation</h2>
<pre><code>import numpy as np
from scipy.spatial import Delaunay
from rtree.index import Index
from pyclipper import PointsInPolygon, scale_to_clipper


def gen_loop_edges(polygon, offset):
    vertex_indices = np.arange(len(polygon))
    edges = np.vstack([vertex_indices, np.roll(vertex_indices, -1, axis=0)]).T
    return edges + offset


def gen_poly_edge_indices(polygons):
    offsets = np.insert(np.cumsum([len(poly) for poly in polygons])[:-1],
                        obj=0,
                        values=0)

    return [
        gen_loop_edges(poly, offset)
        for (poly, offset) in zip(polygons, offsets)
    ]


def gen_poly_edges(polygons):
    poly_edge_indices = gen_poly_edge_indices(polygons)
    return np.vstack(polygons)[np.vstack(poly_edge_indices)]


def gen_poly_rtree(polygons):
    poly_edges = gen_poly_edges(polygons)
    edge_bboxes = np.sort(poly_edges, axis=1).reshape(-1, 4)
    ids = np.arange(len(edge_bboxes))

    poly_rtree = Index()
    for (id, bbox) in zip(ids, edge_bboxes):
        poly_rtree.insert(id, tuple(bbox))

    return poly_edges, poly_rtree


# Reference: https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect
def ccw(A, B, C):
    return (C[:, 1] - A[:, 1]) * (B[:, 0] - A[:, 0]) > (B[:, 1] - A[:, 1]) * (
        C[:, 0] - A[:, 0])


def intersect(A, B, C, D):
    return np.all([ccw(A, C, D) != ccw(B, C, D),
                   ccw(A, B, C) != ccw(A, B, D)],
                  axis=0)


def edge_intersect(key_edge, query_edges):

    key_edge_tiled = np.repeat(key_edge.reshape(1, 2, 2),
                               len(query_edges),
                               axis=0)

    disconnected = np.sum(np.isin(query_edges, key_edge_tiled).reshape(-1, 4),
                          axis=1) == 0

    if np.sum(disconnected) == 0:
        return False

    intersect_check = intersect(key_edge_tiled[disconnected][:, 0, :],
                                key_edge_tiled[disconnected][:, 1, :],
                                query_edges[disconnected][:, 0, :],
                                query_edges[disconnected][:, 1, :])

    if np.sum(intersect_check) > 0:
        return True
    else:
        return False


def adjaceny_list(edges, vertex):
    idx, _ = np.where(edges == vertex)
    query = edges[idx]
    return query[query != vertex].tolist()


# Reference: https://stackoverflow.com/questions/838076/small-cycle-finding-in-a-planar-graph
def find_all_chordless_cycles(all_verts, adjaceny_lists, excluded_edges):

    all_cycles = []
    edge_occurrence_set = set()

    # inner edges shall be traverse twice, while edges belong to the boundary of polygons shall only be travered once
    # if boundary edges were traversed twice, we end up getting boundary of polygons
    for edge in excluded_edges:
        edge_occurrence_set.add((edge[0], edge[1]))

    def find_chordless_cycles(vertex, cycle):
        adj_verts = adjaceny_lists[vertex]

        # filter out edges that already traversed
        adj_verts = list(
            filter(
                lambda adj_vertex:
                (vertex, adj_vertex) not in edge_occurrence_set, adj_verts))

        if len(cycle) == 0 and len(adj_verts) > 0:
            find_chordless_cycles(adj_verts[0], [vertex])
        elif len(cycle) > 0:
            edge_occurrence_set.add((cycle[-1], vertex))
            # don't want to link back
            adj_verts = list(
                filter(lambda adj_vertex: adj_vertex != cycle[-1], adj_verts))

            cycle_found = False
            if vertex in cycle:
                cycle_found = True
                all_cycles.append(cycle[cycle.index(vertex):])

            if len(adj_verts) > 0:
                dir_forward = all_verts[adj_verts] - all_verts[vertex]
                dir_back = np.tile(all_verts[cycle[-1]] - all_verts[vertex],
                                   [len(dir_forward), 1])
                # angle between, clip for robustness
                # FIXME: [use atan2 for robustness](https://stackoverflow.com/questions/10133957/signed-angle-between-two-vectors-without-a-reference-plane)
                angle = np.arccos(
                    np.clip(
                        np.sum(dir_forward * dir_back, axis=1) /
                        (np.linalg.norm(dir_forward, axis=1) *
                         np.linalg.norm(dir_back, axis=1) + 1e-13),
                        -1.0 + 1e-13, 1.0 - 1e-13))

                # sign, positive if at left (CCW), negative if at right (CW)
                opposite = np.sum(
                    np.cross(np.tile([0, 0, 1], [len(dir_forward), 1]),
                             np.insert(dir_back, 2, 0, axis=1))[:, :2] *
                    dir_forward,
                    axis=1) &#x3C; 0
                angle[opposite] = 2 * np.pi - angle[opposite]

                find_chordless_cycles(adj_verts[np.argmin(angle)],
                                      [vertex] if cycle_found else cycle +
                                      [vertex])

    for i in range(len(all_verts)):
        find_chordless_cycles(i, [])

    return all_cycles


def filter_intersecting_triangles(pt, tri, polygons):
    verts = pt[tri]
    verts_next = np.roll(verts, -1, axis=1)
    edges = np.concatenate([verts, verts_next], axis=-1).reshape(-1, 3, 2, 2)
    # we are only interested in edges that does not belong to a polygon
    non_edge_indices = np.abs(np.diff(tri, append=tri[:, 0].reshape(-1,
                                                                    1))) != 1

    query_edges = edges[non_edge_indices]
    query_bboxes = np.sort(query_edges, axis=1).reshape(-1, 4)
    unique_query_bboxes, unique_index, unique_inverse_index = np.unique(
        query_bboxes, return_index=True, return_inverse=True, axis=0)
    unique_query_edges = query_edges[unique_index]

    # not thread safe, cannot be reused
    poly_edges, poly_rtree = gen_poly_rtree(polygons)

    query_results = np.array([
        edge_intersect(key_edge, poly_edges[query_indices])
        for (key_edge, query_indices) in zip(unique_query_edges, [
            list(poly_rtree.intersection(bbox)) for bbox in unique_query_bboxes
        ])
    ])

    edge_intersection_results = np.full_like(tri, False, dtype=bool)
    edge_intersection_results[non_edge_indices] = query_results[
        unique_inverse_index]

    return np.sum(edge_intersection_results, axis=1) > 0


def filter_auxiliary_edges(pt, tri, polygons):
    poly_edges, poly_rtree = gen_poly_rtree(polygons)

    verts = pt[tri]
    verts_next = np.roll(verts, -1, axis=1)
    # filltering needs to be performed at triangle level
    edges = np.concatenate([verts, verts_next], axis=-1).reshape(-1, 3, 2, 2)

    edge_indices = np.concatenate([tri, np.roll(tri, -1, axis=1)],
                                  axis=-1).reshape(-1, 3, 2)

    # we are only interested in edges that does not belong to a polygon
    # first filter out consecutive edges
    non_edge_indices = np.abs(np.diff(tri, append=tri[:, 0].reshape(-1,
                                                                    1))) != 1

    # then filter out polygon last edges
    poly_edge_indices = gen_poly_edge_indices(polygons)
    polygon_last_edges = [
        edge_index[-1].tolist() for edge_index in poly_edge_indices
    ]
    edge_indices_list = edge_indices[non_edge_indices].tolist()
    tmp = non_edge_indices[non_edge_indices]
    tmp[[edge_index in polygon_last_edges
         for edge_index in edge_indices_list]] = False
    non_edge_indices[non_edge_indices] = tmp

    # prepare for rtree query
    query_edges = edges[non_edge_indices]
    query_bboxes = np.sort(query_edges, axis=1).reshape(-1, 4)
    unique_query_bboxes, unique_index, unique_inverse_index = np.unique(
        query_bboxes, return_index=True, return_inverse=True, axis=0)
    unique_query_edges = query_edges[unique_index]

    query_results = np.array([
        edge_intersect(key_edge, poly_edges[query_indices])
        for (key_edge, query_indices) in zip(unique_query_edges, [
            list(poly_rtree.intersection(bbox)) for bbox in unique_query_bboxes
        ])
    ])

    auxiliary_edges = edge_indices[non_edge_indices][unique_index][np.invert(
        query_results)]

    return np.vstack(poly_edge_indices), auxiliary_edges


def delaunay_triangulation(exterior_polygons, interior_polygons):
    tri = Delaunay(np.vstack(exterior_polygons + interior_polygons))

    # triangle is convex
    barycenters_clipper = np.sum(
        np.array(scale_to_clipper(tri.points))[tri.simplices], axis=1) / 3

    def barycenters_in_polygons(polygons):
        return [
            PointsInPolygon(barycenters_clipper, scale_to_clipper(polygon))
            for polygon in polygons
        ]

    points_in_exterior = np.any(np.array(
        barycenters_in_polygons(exterior_polygons)) == 1,
                                axis=0)
    point_not_in_interior = np.all(np.array(
        barycenters_in_polygons(interior_polygons)) == 0,
                                   axis=0)

    if not exterior_polygons:
        points_in_exterior = [True] * len(points_in_exterior)

    if not interior_polygons:
        point_not_in_interior = [True] * len(points_in_exterior)

    valid_indices = np.all((points_in_exterior, point_not_in_interior), axis=0)

    if not exterior_polygons or not interior_polygons:
        tmp = valid_indices[valid_indices]
        tmp[filter_intersecting_triangles(
            tri.points, tri.simplices[valid_indices],
            exterior_polygons + interior_polygons)] = False

        valid_indices[valid_indices] = tmp

        return tri.points, tri.simplices[valid_indices].tolist()

    else:
        poly_edges, auxiliary_edges = filter_auxiliary_edges(
            tri.points, tri.simplices[valid_indices],
            exterior_polygons + interior_polygons)

        all_edges = np.vstack([poly_edges, auxiliary_edges])
        adjaceny_lists = [
            adjaceny_list(all_edges, i) for i in range(len(tri.points))
        ]
        return tri.points, find_all_chordless_cycles(tri.points,
                                                     adjaceny_lists,
                                                     poly_edges)
</code></pre>
<blockquote>
<p>Patch for pyclipper</p>
</blockquote>
<pre><code>diff --git a/src/pyclipper/_pyclipper.pyx b/src/pyclipper/_pyclipper.pyx
index bb179a1..a952a01 100644
--- a/src/pyclipper/_pyclipper.pyx
+++ b/src/pyclipper/_pyclipper.pyx
@@ -319,6 +319,33 @@ def PointInPolygon(point, poly):
     return result
 
 
+def PointsInPolygon(points, poly):
+    """ Determine where does the point lie regarding the provided polygon.
+    More info: http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Functions/PointInPolygon.htm
+
+    Keyword arguments:
+    points -- a list of positions in question
+    poly  -- closed polygon
+
+    Returns:
+    List of array the same length as points, with each of its element
+        0  -- point is not in polygon
+        -1 -- point is on polygon
+        1  -- point is in polygon
+    """
+
+    cdef Path c_path = _to_clipper_path(poly)
+    cdef IntPoint *c_points = &#x3C;IntPoint *> malloc(len(points) * sizeof(IntPoint))
+    cdef int* results = &#x3C;int *> malloc(len(points) * sizeof(int))
+    for i in range(len(points)):
+        c_points[i] = _to_clipper_point(points[i])
+        with nogil:
+            results[i] = &#x3C;int>c_PointInPolygon(c_points[i], c_path)
+    results_python = [results[i] for i in range(len(points))]
+    free(c_points)
+    return results_python
+
+
 def SimplifyPolygon(poly, PolyFillType fill_type=pftEvenOdd):
     """ Removes self-intersections from the supplied polygon.
     More info: http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Functions/SimplifyPolygon.htm
</code></pre>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/my-personal-knowledge-cache/notes/wdxd75nh2cs2qklj06exvmx">Signed Distance Function</a></li>
<li><a href="/my-personal-knowledge-cache/notes/ww8z42lj1f2cm9lj0yx3ubc">Neighbourhood Connectivity</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#steps" title="Steps:">Steps:</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#implementation" title="Implementation">Implementation</a></div></div></div></div></div></div></div></div></div></main><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></section></section></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"6xcpu4fh3at4bbmptj9c8nr","title":"Connect Polygons with Their Offset Ones","desc":"","updated":1646980246694,"created":1646726929486,"custom":{},"fname":"polygon.connect-polygons-with-their-offset-ones","type":"note","vault":{"fsPath":"vault"},"contentHash":"eb692d316a0e9ad089d98fdc01bea032","links":[{"from":{"fname":"geometry.signed-distance-function","vaultName":"vault"},"type":"backlink","position":{"start":{"line":84,"column":50,"offset":3391},"end":{"line":84,"column":101,"offset":3442},"indent":[]},"value":"polygon.connect-polygons-with-their-offset-ones","alias":"polygon.connect-polygons-with-their-offset-ones"},{"from":{"fname":"code-read.igl.neighbourhood-connectivity","vaultName":"vault"},"type":"backlink","position":{"start":{"line":50,"column":28,"offset":1089},"end":{"line":50,"column":109,"offset":1170},"indent":[]},"value":"polygon.connect-polygons-with-their-offset-ones","alias":"Implementation"}],"anchors":{"steps":{"type":"header","text":"Steps:","value":"steps","line":8,"column":0,"depth":2},"implementation":{"type":"header","text":"Implementation","value":"implementation","line":16,"column":0,"depth":2}},"children":[],"parent":"npuhs4xvm0sa31rz2gcuff3","data":{}},"body":"\u003ch1 id=\"connect-polygons-with-their-offset-ones\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#connect-polygons-with-their-offset-ones\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eConnect Polygons with Their Offset Ones\u003c/h1\u003e\n\u003ch2 id=\"steps\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#steps\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eSteps:\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eGet list of edges for exterior and interior polygons\u003c/li\u003e\n\u003cli\u003eForce exterior to be CCW, interior to be CW\u003c/li\u003e\n\u003cli\u003eApply delaunay triangulation\u003c/li\u003e\n\u003cli\u003eFor each delaunay triangle, find the ones that do not intersect with exterior/interior polygons, append its non-polygon edges\u003c/li\u003e\n\u003cli\u003eFind all chordless cycles in undirected graph using wall-walking algorithm (ignore CW traversal of boundary edges)\u003c/li\u003e\n\u003cli\u003eTreat all chordless cycles as faces. For non-triangle faces, tessellated them if necessary\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"implementation\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#implementation\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eImplementation\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport numpy as np\nfrom scipy.spatial import Delaunay\nfrom rtree.index import Index\nfrom pyclipper import PointsInPolygon, scale_to_clipper\n\n\ndef gen_loop_edges(polygon, offset):\n    vertex_indices = np.arange(len(polygon))\n    edges = np.vstack([vertex_indices, np.roll(vertex_indices, -1, axis=0)]).T\n    return edges + offset\n\n\ndef gen_poly_edge_indices(polygons):\n    offsets = np.insert(np.cumsum([len(poly) for poly in polygons])[:-1],\n                        obj=0,\n                        values=0)\n\n    return [\n        gen_loop_edges(poly, offset)\n        for (poly, offset) in zip(polygons, offsets)\n    ]\n\n\ndef gen_poly_edges(polygons):\n    poly_edge_indices = gen_poly_edge_indices(polygons)\n    return np.vstack(polygons)[np.vstack(poly_edge_indices)]\n\n\ndef gen_poly_rtree(polygons):\n    poly_edges = gen_poly_edges(polygons)\n    edge_bboxes = np.sort(poly_edges, axis=1).reshape(-1, 4)\n    ids = np.arange(len(edge_bboxes))\n\n    poly_rtree = Index()\n    for (id, bbox) in zip(ids, edge_bboxes):\n        poly_rtree.insert(id, tuple(bbox))\n\n    return poly_edges, poly_rtree\n\n\n# Reference: https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\ndef ccw(A, B, C):\n    return (C[:, 1] - A[:, 1]) * (B[:, 0] - A[:, 0]) \u003e (B[:, 1] - A[:, 1]) * (\n        C[:, 0] - A[:, 0])\n\n\ndef intersect(A, B, C, D):\n    return np.all([ccw(A, C, D) != ccw(B, C, D),\n                   ccw(A, B, C) != ccw(A, B, D)],\n                  axis=0)\n\n\ndef edge_intersect(key_edge, query_edges):\n\n    key_edge_tiled = np.repeat(key_edge.reshape(1, 2, 2),\n                               len(query_edges),\n                               axis=0)\n\n    disconnected = np.sum(np.isin(query_edges, key_edge_tiled).reshape(-1, 4),\n                          axis=1) == 0\n\n    if np.sum(disconnected) == 0:\n        return False\n\n    intersect_check = intersect(key_edge_tiled[disconnected][:, 0, :],\n                                key_edge_tiled[disconnected][:, 1, :],\n                                query_edges[disconnected][:, 0, :],\n                                query_edges[disconnected][:, 1, :])\n\n    if np.sum(intersect_check) \u003e 0:\n        return True\n    else:\n        return False\n\n\ndef adjaceny_list(edges, vertex):\n    idx, _ = np.where(edges == vertex)\n    query = edges[idx]\n    return query[query != vertex].tolist()\n\n\n# Reference: https://stackoverflow.com/questions/838076/small-cycle-finding-in-a-planar-graph\ndef find_all_chordless_cycles(all_verts, adjaceny_lists, excluded_edges):\n\n    all_cycles = []\n    edge_occurrence_set = set()\n\n    # inner edges shall be traverse twice, while edges belong to the boundary of polygons shall only be travered once\n    # if boundary edges were traversed twice, we end up getting boundary of polygons\n    for edge in excluded_edges:\n        edge_occurrence_set.add((edge[0], edge[1]))\n\n    def find_chordless_cycles(vertex, cycle):\n        adj_verts = adjaceny_lists[vertex]\n\n        # filter out edges that already traversed\n        adj_verts = list(\n            filter(\n                lambda adj_vertex:\n                (vertex, adj_vertex) not in edge_occurrence_set, adj_verts))\n\n        if len(cycle) == 0 and len(adj_verts) \u003e 0:\n            find_chordless_cycles(adj_verts[0], [vertex])\n        elif len(cycle) \u003e 0:\n            edge_occurrence_set.add((cycle[-1], vertex))\n            # don't want to link back\n            adj_verts = list(\n                filter(lambda adj_vertex: adj_vertex != cycle[-1], adj_verts))\n\n            cycle_found = False\n            if vertex in cycle:\n                cycle_found = True\n                all_cycles.append(cycle[cycle.index(vertex):])\n\n            if len(adj_verts) \u003e 0:\n                dir_forward = all_verts[adj_verts] - all_verts[vertex]\n                dir_back = np.tile(all_verts[cycle[-1]] - all_verts[vertex],\n                                   [len(dir_forward), 1])\n                # angle between, clip for robustness\n                # FIXME: [use atan2 for robustness](https://stackoverflow.com/questions/10133957/signed-angle-between-two-vectors-without-a-reference-plane)\n                angle = np.arccos(\n                    np.clip(\n                        np.sum(dir_forward * dir_back, axis=1) /\n                        (np.linalg.norm(dir_forward, axis=1) *\n                         np.linalg.norm(dir_back, axis=1) + 1e-13),\n                        -1.0 + 1e-13, 1.0 - 1e-13))\n\n                # sign, positive if at left (CCW), negative if at right (CW)\n                opposite = np.sum(\n                    np.cross(np.tile([0, 0, 1], [len(dir_forward), 1]),\n                             np.insert(dir_back, 2, 0, axis=1))[:, :2] *\n                    dir_forward,\n                    axis=1) \u0026#x3C; 0\n                angle[opposite] = 2 * np.pi - angle[opposite]\n\n                find_chordless_cycles(adj_verts[np.argmin(angle)],\n                                      [vertex] if cycle_found else cycle +\n                                      [vertex])\n\n    for i in range(len(all_verts)):\n        find_chordless_cycles(i, [])\n\n    return all_cycles\n\n\ndef filter_intersecting_triangles(pt, tri, polygons):\n    verts = pt[tri]\n    verts_next = np.roll(verts, -1, axis=1)\n    edges = np.concatenate([verts, verts_next], axis=-1).reshape(-1, 3, 2, 2)\n    # we are only interested in edges that does not belong to a polygon\n    non_edge_indices = np.abs(np.diff(tri, append=tri[:, 0].reshape(-1,\n                                                                    1))) != 1\n\n    query_edges = edges[non_edge_indices]\n    query_bboxes = np.sort(query_edges, axis=1).reshape(-1, 4)\n    unique_query_bboxes, unique_index, unique_inverse_index = np.unique(\n        query_bboxes, return_index=True, return_inverse=True, axis=0)\n    unique_query_edges = query_edges[unique_index]\n\n    # not thread safe, cannot be reused\n    poly_edges, poly_rtree = gen_poly_rtree(polygons)\n\n    query_results = np.array([\n        edge_intersect(key_edge, poly_edges[query_indices])\n        for (key_edge, query_indices) in zip(unique_query_edges, [\n            list(poly_rtree.intersection(bbox)) for bbox in unique_query_bboxes\n        ])\n    ])\n\n    edge_intersection_results = np.full_like(tri, False, dtype=bool)\n    edge_intersection_results[non_edge_indices] = query_results[\n        unique_inverse_index]\n\n    return np.sum(edge_intersection_results, axis=1) \u003e 0\n\n\ndef filter_auxiliary_edges(pt, tri, polygons):\n    poly_edges, poly_rtree = gen_poly_rtree(polygons)\n\n    verts = pt[tri]\n    verts_next = np.roll(verts, -1, axis=1)\n    # filltering needs to be performed at triangle level\n    edges = np.concatenate([verts, verts_next], axis=-1).reshape(-1, 3, 2, 2)\n\n    edge_indices = np.concatenate([tri, np.roll(tri, -1, axis=1)],\n                                  axis=-1).reshape(-1, 3, 2)\n\n    # we are only interested in edges that does not belong to a polygon\n    # first filter out consecutive edges\n    non_edge_indices = np.abs(np.diff(tri, append=tri[:, 0].reshape(-1,\n                                                                    1))) != 1\n\n    # then filter out polygon last edges\n    poly_edge_indices = gen_poly_edge_indices(polygons)\n    polygon_last_edges = [\n        edge_index[-1].tolist() for edge_index in poly_edge_indices\n    ]\n    edge_indices_list = edge_indices[non_edge_indices].tolist()\n    tmp = non_edge_indices[non_edge_indices]\n    tmp[[edge_index in polygon_last_edges\n         for edge_index in edge_indices_list]] = False\n    non_edge_indices[non_edge_indices] = tmp\n\n    # prepare for rtree query\n    query_edges = edges[non_edge_indices]\n    query_bboxes = np.sort(query_edges, axis=1).reshape(-1, 4)\n    unique_query_bboxes, unique_index, unique_inverse_index = np.unique(\n        query_bboxes, return_index=True, return_inverse=True, axis=0)\n    unique_query_edges = query_edges[unique_index]\n\n    query_results = np.array([\n        edge_intersect(key_edge, poly_edges[query_indices])\n        for (key_edge, query_indices) in zip(unique_query_edges, [\n            list(poly_rtree.intersection(bbox)) for bbox in unique_query_bboxes\n        ])\n    ])\n\n    auxiliary_edges = edge_indices[non_edge_indices][unique_index][np.invert(\n        query_results)]\n\n    return np.vstack(poly_edge_indices), auxiliary_edges\n\n\ndef delaunay_triangulation(exterior_polygons, interior_polygons):\n    tri = Delaunay(np.vstack(exterior_polygons + interior_polygons))\n\n    # triangle is convex\n    barycenters_clipper = np.sum(\n        np.array(scale_to_clipper(tri.points))[tri.simplices], axis=1) / 3\n\n    def barycenters_in_polygons(polygons):\n        return [\n            PointsInPolygon(barycenters_clipper, scale_to_clipper(polygon))\n            for polygon in polygons\n        ]\n\n    points_in_exterior = np.any(np.array(\n        barycenters_in_polygons(exterior_polygons)) == 1,\n                                axis=0)\n    point_not_in_interior = np.all(np.array(\n        barycenters_in_polygons(interior_polygons)) == 0,\n                                   axis=0)\n\n    if not exterior_polygons:\n        points_in_exterior = [True] * len(points_in_exterior)\n\n    if not interior_polygons:\n        point_not_in_interior = [True] * len(points_in_exterior)\n\n    valid_indices = np.all((points_in_exterior, point_not_in_interior), axis=0)\n\n    if not exterior_polygons or not interior_polygons:\n        tmp = valid_indices[valid_indices]\n        tmp[filter_intersecting_triangles(\n            tri.points, tri.simplices[valid_indices],\n            exterior_polygons + interior_polygons)] = False\n\n        valid_indices[valid_indices] = tmp\n\n        return tri.points, tri.simplices[valid_indices].tolist()\n\n    else:\n        poly_edges, auxiliary_edges = filter_auxiliary_edges(\n            tri.points, tri.simplices[valid_indices],\n            exterior_polygons + interior_polygons)\n\n        all_edges = np.vstack([poly_edges, auxiliary_edges])\n        adjaceny_lists = [\n            adjaceny_list(all_edges, i) for i in range(len(tri.points))\n        ]\n        return tri.points, find_all_chordless_cycles(tri.points,\n                                                     adjaceny_lists,\n                                                     poly_edges)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePatch for pyclipper\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode\u003ediff --git a/src/pyclipper/_pyclipper.pyx b/src/pyclipper/_pyclipper.pyx\nindex bb179a1..a952a01 100644\n--- a/src/pyclipper/_pyclipper.pyx\n+++ b/src/pyclipper/_pyclipper.pyx\n@@ -319,6 +319,33 @@ def PointInPolygon(point, poly):\n     return result\n \n \n+def PointsInPolygon(points, poly):\n+    \"\"\" Determine where does the point lie regarding the provided polygon.\n+    More info: http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Functions/PointInPolygon.htm\n+\n+    Keyword arguments:\n+    points -- a list of positions in question\n+    poly  -- closed polygon\n+\n+    Returns:\n+    List of array the same length as points, with each of its element\n+        0  -- point is not in polygon\n+        -1 -- point is on polygon\n+        1  -- point is in polygon\n+    \"\"\"\n+\n+    cdef Path c_path = _to_clipper_path(poly)\n+    cdef IntPoint *c_points = \u0026#x3C;IntPoint *\u003e malloc(len(points) * sizeof(IntPoint))\n+    cdef int* results = \u0026#x3C;int *\u003e malloc(len(points) * sizeof(int))\n+    for i in range(len(points)):\n+        c_points[i] = _to_clipper_point(points[i])\n+        with nogil:\n+            results[i] = \u0026#x3C;int\u003ec_PointInPolygon(c_points[i], c_path)\n+    results_python = [results[i] for i in range(len(points))]\n+    free(c_points)\n+    return results_python\n+\n+\n def SimplifyPolygon(poly, PolyFillType fill_type=pftEvenOdd):\n     \"\"\" Removes self-intersections from the supplied polygon.\n     More info: http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Functions/SimplifyPolygon.htm\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cstrong\u003eBacklinks\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/my-personal-knowledge-cache/notes/wdxd75nh2cs2qklj06exvmx\"\u003eSigned Distance Function\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/my-personal-knowledge-cache/notes/ww8z42lj1f2cm9lj0yx3ubc\"\u003eNeighbourhood Connectivity\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"o3PkEany5FTDLokev2jkJ","title":"Root","desc":"","updated":1656832289330,"created":1640014633146,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"1f4a8dbd787743b10f24422968be02a9","links":[],"anchors":{"history":{"type":"header","text":"History","value":"history","line":10,"column":0,"depth":2},"disclaimer":{"type":"header","text":"Disclaimer","value":"disclaimer","line":15,"column":0,"depth":2}},"children":["Vn1Ykq4aIagi0bhZowkgD","ja5HFaIxVEtbZoTklNXfZ","vnzxfoqb6aqbrqy247uonqo","jjlv4wd30bvf0r680o9ptbi","kok8aerdrzko8v4i6w6qtjx","hr8ruqfxd2miwldyehzz5zy","criy8usqjrguecufwb3k8z2","3x9f9wclumzxc23dzgraepy","sma2hkp8hvq9urmtk94qqwq","4bcvwahaynsox941d8dimxw","8u19znq05xj50ptse0fq8nj","hbcft05imtwxxtwk52nij1n","2vmt81onv3jf06ejwfusj30","npuhs4xvm0sa31rz2gcuff3","mwt2mrjm58oa3q2osoqwd64","yjnf5fuac95jbdmjj923hyh","17p3nbv4rvga83hhsz2idzp","8r1egy8mz3lp7ud9p8kcg8z","5gf8xb68r1y0kxumkvvmuez","d92qhaqtfbt7e4eximdnbht","r25bm5nuug9krur6ddqearm"],"parent":null,"data":{},"body":"\nMy personal knowledge cache using [Dendron](https://www.dendron.so)\n\n## History\nIt was during my first job, at the start-up company called PixelShift.AI, that I acquired most prominent skill as a software engineer-the ability to read source code. It opened up a new way of learning and my knowledge expanded rapidly ever since. Learning new things is thriving but noting them down cogently and organized is hard. I often found myself forget the context few month later, making the notes completely intelligible. Additionally, some notes need frequent update as my previous understanding could be parochial, antiquated or even erroneous.\n\nIn desperate attempt to facilitate the noting/updating experience, I came across [Dendron](https://www.dendron.so) and found it surprisingly congenial to my personal need. With it, I have gradually grown the habit of caching, linking back and extending my knowledge base.\n\n## Disclaimer\nThe notes are collections of information I found along the journey. I use backquote to denote sources, but I am likely to miss some references, so apology in advance. Also, they are my personal understandings, usually added when I first encounter the topic and will be updated only when I come across it again, so some of them could be incomplete or wrong."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.86.1","enableFullHierarchyNoteTitle":false,"enableHandlebarTemplates":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"enableSiteLastModified":true,"siteRootDir":"docs","enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"writeStubs":false,"seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enablePrettyLinks":true,"assetsPrefix":"/my-personal-knowledge-cache","siteUrl":"https://ankbzpx.github.io","enableTaskNotes":true,"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"6xcpu4fh3at4bbmptj9c8nr"},"buildId":"ihOclfcI71GY0CxNfF2GS","assetPrefix":"/my-personal-knowledge-cache","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>