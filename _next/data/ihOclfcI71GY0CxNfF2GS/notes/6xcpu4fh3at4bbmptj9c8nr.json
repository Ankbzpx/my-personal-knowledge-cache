{"pageProps":{"note":{"id":"6xcpu4fh3at4bbmptj9c8nr","title":"Connect Polygons with Their Offset Ones","desc":"","updated":1646980246694,"created":1646726929486,"custom":{},"fname":"polygon.connect-polygons-with-their-offset-ones","type":"note","vault":{"fsPath":"vault"},"contentHash":"eb692d316a0e9ad089d98fdc01bea032","links":[{"from":{"fname":"geometry.signed-distance-function","vaultName":"vault"},"type":"backlink","position":{"start":{"line":84,"column":50,"offset":3391},"end":{"line":84,"column":101,"offset":3442},"indent":[]},"value":"polygon.connect-polygons-with-their-offset-ones","alias":"polygon.connect-polygons-with-their-offset-ones"},{"from":{"fname":"code-read.igl.neighbourhood-connectivity","vaultName":"vault"},"type":"backlink","position":{"start":{"line":50,"column":28,"offset":1089},"end":{"line":50,"column":109,"offset":1170},"indent":[]},"value":"polygon.connect-polygons-with-their-offset-ones","alias":"Implementation"}],"anchors":{"steps":{"type":"header","text":"Steps:","value":"steps","line":8,"column":0,"depth":2},"implementation":{"type":"header","text":"Implementation","value":"implementation","line":16,"column":0,"depth":2}},"children":[],"parent":"npuhs4xvm0sa31rz2gcuff3","data":{}},"body":"<h1 id=\"connect-polygons-with-their-offset-ones\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#connect-polygons-with-their-offset-ones\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Connect Polygons with Their Offset Ones</h1>\n<h2 id=\"steps\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#steps\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Steps:</h2>\n<ol>\n<li>Get list of edges for exterior and interior polygons</li>\n<li>Force exterior to be CCW, interior to be CW</li>\n<li>Apply delaunay triangulation</li>\n<li>For each delaunay triangle, find the ones that do not intersect with exterior/interior polygons, append its non-polygon edges</li>\n<li>Find all chordless cycles in undirected graph using wall-walking algorithm (ignore CW traversal of boundary edges)</li>\n<li>Treat all chordless cycles as faces. For non-triangle faces, tessellated them if necessary</li>\n</ol>\n<h2 id=\"implementation\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#implementation\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>Implementation</h2>\n<pre><code>import numpy as np\nfrom scipy.spatial import Delaunay\nfrom rtree.index import Index\nfrom pyclipper import PointsInPolygon, scale_to_clipper\n\n\ndef gen_loop_edges(polygon, offset):\n    vertex_indices = np.arange(len(polygon))\n    edges = np.vstack([vertex_indices, np.roll(vertex_indices, -1, axis=0)]).T\n    return edges + offset\n\n\ndef gen_poly_edge_indices(polygons):\n    offsets = np.insert(np.cumsum([len(poly) for poly in polygons])[:-1],\n                        obj=0,\n                        values=0)\n\n    return [\n        gen_loop_edges(poly, offset)\n        for (poly, offset) in zip(polygons, offsets)\n    ]\n\n\ndef gen_poly_edges(polygons):\n    poly_edge_indices = gen_poly_edge_indices(polygons)\n    return np.vstack(polygons)[np.vstack(poly_edge_indices)]\n\n\ndef gen_poly_rtree(polygons):\n    poly_edges = gen_poly_edges(polygons)\n    edge_bboxes = np.sort(poly_edges, axis=1).reshape(-1, 4)\n    ids = np.arange(len(edge_bboxes))\n\n    poly_rtree = Index()\n    for (id, bbox) in zip(ids, edge_bboxes):\n        poly_rtree.insert(id, tuple(bbox))\n\n    return poly_edges, poly_rtree\n\n\n# Reference: https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\ndef ccw(A, B, C):\n    return (C[:, 1] - A[:, 1]) * (B[:, 0] - A[:, 0]) > (B[:, 1] - A[:, 1]) * (\n        C[:, 0] - A[:, 0])\n\n\ndef intersect(A, B, C, D):\n    return np.all([ccw(A, C, D) != ccw(B, C, D),\n                   ccw(A, B, C) != ccw(A, B, D)],\n                  axis=0)\n\n\ndef edge_intersect(key_edge, query_edges):\n\n    key_edge_tiled = np.repeat(key_edge.reshape(1, 2, 2),\n                               len(query_edges),\n                               axis=0)\n\n    disconnected = np.sum(np.isin(query_edges, key_edge_tiled).reshape(-1, 4),\n                          axis=1) == 0\n\n    if np.sum(disconnected) == 0:\n        return False\n\n    intersect_check = intersect(key_edge_tiled[disconnected][:, 0, :],\n                                key_edge_tiled[disconnected][:, 1, :],\n                                query_edges[disconnected][:, 0, :],\n                                query_edges[disconnected][:, 1, :])\n\n    if np.sum(intersect_check) > 0:\n        return True\n    else:\n        return False\n\n\ndef adjaceny_list(edges, vertex):\n    idx, _ = np.where(edges == vertex)\n    query = edges[idx]\n    return query[query != vertex].tolist()\n\n\n# Reference: https://stackoverflow.com/questions/838076/small-cycle-finding-in-a-planar-graph\ndef find_all_chordless_cycles(all_verts, adjaceny_lists, excluded_edges):\n\n    all_cycles = []\n    edge_occurrence_set = set()\n\n    # inner edges shall be traverse twice, while edges belong to the boundary of polygons shall only be travered once\n    # if boundary edges were traversed twice, we end up getting boundary of polygons\n    for edge in excluded_edges:\n        edge_occurrence_set.add((edge[0], edge[1]))\n\n    def find_chordless_cycles(vertex, cycle):\n        adj_verts = adjaceny_lists[vertex]\n\n        # filter out edges that already traversed\n        adj_verts = list(\n            filter(\n                lambda adj_vertex:\n                (vertex, adj_vertex) not in edge_occurrence_set, adj_verts))\n\n        if len(cycle) == 0 and len(adj_verts) > 0:\n            find_chordless_cycles(adj_verts[0], [vertex])\n        elif len(cycle) > 0:\n            edge_occurrence_set.add((cycle[-1], vertex))\n            # don't want to link back\n            adj_verts = list(\n                filter(lambda adj_vertex: adj_vertex != cycle[-1], adj_verts))\n\n            cycle_found = False\n            if vertex in cycle:\n                cycle_found = True\n                all_cycles.append(cycle[cycle.index(vertex):])\n\n            if len(adj_verts) > 0:\n                dir_forward = all_verts[adj_verts] - all_verts[vertex]\n                dir_back = np.tile(all_verts[cycle[-1]] - all_verts[vertex],\n                                   [len(dir_forward), 1])\n                # angle between, clip for robustness\n                # FIXME: [use atan2 for robustness](https://stackoverflow.com/questions/10133957/signed-angle-between-two-vectors-without-a-reference-plane)\n                angle = np.arccos(\n                    np.clip(\n                        np.sum(dir_forward * dir_back, axis=1) /\n                        (np.linalg.norm(dir_forward, axis=1) *\n                         np.linalg.norm(dir_back, axis=1) + 1e-13),\n                        -1.0 + 1e-13, 1.0 - 1e-13))\n\n                # sign, positive if at left (CCW), negative if at right (CW)\n                opposite = np.sum(\n                    np.cross(np.tile([0, 0, 1], [len(dir_forward), 1]),\n                             np.insert(dir_back, 2, 0, axis=1))[:, :2] *\n                    dir_forward,\n                    axis=1) &#x3C; 0\n                angle[opposite] = 2 * np.pi - angle[opposite]\n\n                find_chordless_cycles(adj_verts[np.argmin(angle)],\n                                      [vertex] if cycle_found else cycle +\n                                      [vertex])\n\n    for i in range(len(all_verts)):\n        find_chordless_cycles(i, [])\n\n    return all_cycles\n\n\ndef filter_intersecting_triangles(pt, tri, polygons):\n    verts = pt[tri]\n    verts_next = np.roll(verts, -1, axis=1)\n    edges = np.concatenate([verts, verts_next], axis=-1).reshape(-1, 3, 2, 2)\n    # we are only interested in edges that does not belong to a polygon\n    non_edge_indices = np.abs(np.diff(tri, append=tri[:, 0].reshape(-1,\n                                                                    1))) != 1\n\n    query_edges = edges[non_edge_indices]\n    query_bboxes = np.sort(query_edges, axis=1).reshape(-1, 4)\n    unique_query_bboxes, unique_index, unique_inverse_index = np.unique(\n        query_bboxes, return_index=True, return_inverse=True, axis=0)\n    unique_query_edges = query_edges[unique_index]\n\n    # not thread safe, cannot be reused\n    poly_edges, poly_rtree = gen_poly_rtree(polygons)\n\n    query_results = np.array([\n        edge_intersect(key_edge, poly_edges[query_indices])\n        for (key_edge, query_indices) in zip(unique_query_edges, [\n            list(poly_rtree.intersection(bbox)) for bbox in unique_query_bboxes\n        ])\n    ])\n\n    edge_intersection_results = np.full_like(tri, False, dtype=bool)\n    edge_intersection_results[non_edge_indices] = query_results[\n        unique_inverse_index]\n\n    return np.sum(edge_intersection_results, axis=1) > 0\n\n\ndef filter_auxiliary_edges(pt, tri, polygons):\n    poly_edges, poly_rtree = gen_poly_rtree(polygons)\n\n    verts = pt[tri]\n    verts_next = np.roll(verts, -1, axis=1)\n    # filltering needs to be performed at triangle level\n    edges = np.concatenate([verts, verts_next], axis=-1).reshape(-1, 3, 2, 2)\n\n    edge_indices = np.concatenate([tri, np.roll(tri, -1, axis=1)],\n                                  axis=-1).reshape(-1, 3, 2)\n\n    # we are only interested in edges that does not belong to a polygon\n    # first filter out consecutive edges\n    non_edge_indices = np.abs(np.diff(tri, append=tri[:, 0].reshape(-1,\n                                                                    1))) != 1\n\n    # then filter out polygon last edges\n    poly_edge_indices = gen_poly_edge_indices(polygons)\n    polygon_last_edges = [\n        edge_index[-1].tolist() for edge_index in poly_edge_indices\n    ]\n    edge_indices_list = edge_indices[non_edge_indices].tolist()\n    tmp = non_edge_indices[non_edge_indices]\n    tmp[[edge_index in polygon_last_edges\n         for edge_index in edge_indices_list]] = False\n    non_edge_indices[non_edge_indices] = tmp\n\n    # prepare for rtree query\n    query_edges = edges[non_edge_indices]\n    query_bboxes = np.sort(query_edges, axis=1).reshape(-1, 4)\n    unique_query_bboxes, unique_index, unique_inverse_index = np.unique(\n        query_bboxes, return_index=True, return_inverse=True, axis=0)\n    unique_query_edges = query_edges[unique_index]\n\n    query_results = np.array([\n        edge_intersect(key_edge, poly_edges[query_indices])\n        for (key_edge, query_indices) in zip(unique_query_edges, [\n            list(poly_rtree.intersection(bbox)) for bbox in unique_query_bboxes\n        ])\n    ])\n\n    auxiliary_edges = edge_indices[non_edge_indices][unique_index][np.invert(\n        query_results)]\n\n    return np.vstack(poly_edge_indices), auxiliary_edges\n\n\ndef delaunay_triangulation(exterior_polygons, interior_polygons):\n    tri = Delaunay(np.vstack(exterior_polygons + interior_polygons))\n\n    # triangle is convex\n    barycenters_clipper = np.sum(\n        np.array(scale_to_clipper(tri.points))[tri.simplices], axis=1) / 3\n\n    def barycenters_in_polygons(polygons):\n        return [\n            PointsInPolygon(barycenters_clipper, scale_to_clipper(polygon))\n            for polygon in polygons\n        ]\n\n    points_in_exterior = np.any(np.array(\n        barycenters_in_polygons(exterior_polygons)) == 1,\n                                axis=0)\n    point_not_in_interior = np.all(np.array(\n        barycenters_in_polygons(interior_polygons)) == 0,\n                                   axis=0)\n\n    if not exterior_polygons:\n        points_in_exterior = [True] * len(points_in_exterior)\n\n    if not interior_polygons:\n        point_not_in_interior = [True] * len(points_in_exterior)\n\n    valid_indices = np.all((points_in_exterior, point_not_in_interior), axis=0)\n\n    if not exterior_polygons or not interior_polygons:\n        tmp = valid_indices[valid_indices]\n        tmp[filter_intersecting_triangles(\n            tri.points, tri.simplices[valid_indices],\n            exterior_polygons + interior_polygons)] = False\n\n        valid_indices[valid_indices] = tmp\n\n        return tri.points, tri.simplices[valid_indices].tolist()\n\n    else:\n        poly_edges, auxiliary_edges = filter_auxiliary_edges(\n            tri.points, tri.simplices[valid_indices],\n            exterior_polygons + interior_polygons)\n\n        all_edges = np.vstack([poly_edges, auxiliary_edges])\n        adjaceny_lists = [\n            adjaceny_list(all_edges, i) for i in range(len(tri.points))\n        ]\n        return tri.points, find_all_chordless_cycles(tri.points,\n                                                     adjaceny_lists,\n                                                     poly_edges)\n</code></pre>\n<blockquote>\n<p>Patch for pyclipper</p>\n</blockquote>\n<pre><code>diff --git a/src/pyclipper/_pyclipper.pyx b/src/pyclipper/_pyclipper.pyx\nindex bb179a1..a952a01 100644\n--- a/src/pyclipper/_pyclipper.pyx\n+++ b/src/pyclipper/_pyclipper.pyx\n@@ -319,6 +319,33 @@ def PointInPolygon(point, poly):\n     return result\n \n \n+def PointsInPolygon(points, poly):\n+    \"\"\" Determine where does the point lie regarding the provided polygon.\n+    More info: http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Functions/PointInPolygon.htm\n+\n+    Keyword arguments:\n+    points -- a list of positions in question\n+    poly  -- closed polygon\n+\n+    Returns:\n+    List of array the same length as points, with each of its element\n+        0  -- point is not in polygon\n+        -1 -- point is on polygon\n+        1  -- point is in polygon\n+    \"\"\"\n+\n+    cdef Path c_path = _to_clipper_path(poly)\n+    cdef IntPoint *c_points = &#x3C;IntPoint *> malloc(len(points) * sizeof(IntPoint))\n+    cdef int* results = &#x3C;int *> malloc(len(points) * sizeof(int))\n+    for i in range(len(points)):\n+        c_points[i] = _to_clipper_point(points[i])\n+        with nogil:\n+            results[i] = &#x3C;int>c_PointInPolygon(c_points[i], c_path)\n+    results_python = [results[i] for i in range(len(points))]\n+    free(c_points)\n+    return results_python\n+\n+\n def SimplifyPolygon(poly, PolyFillType fill_type=pftEvenOdd):\n     \"\"\" Removes self-intersections from the supplied polygon.\n     More info: http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Functions/SimplifyPolygon.htm\n</code></pre>\n<hr>\n<strong>Backlinks</strong>\n<ul>\n<li><a href=\"/my-personal-knowledge-cache/notes/wdxd75nh2cs2qklj06exvmx\">Signed Distance Function</a></li>\n<li><a href=\"/my-personal-knowledge-cache/notes/ww8z42lj1f2cm9lj0yx3ubc\">Neighbourhood Connectivity</a></li>\n</ul>","noteIndex":{"id":"o3PkEany5FTDLokev2jkJ","title":"Root","desc":"","updated":1656832289330,"created":1640014633146,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"1f4a8dbd787743b10f24422968be02a9","links":[],"anchors":{"history":{"type":"header","text":"History","value":"history","line":10,"column":0,"depth":2},"disclaimer":{"type":"header","text":"Disclaimer","value":"disclaimer","line":15,"column":0,"depth":2}},"children":["Vn1Ykq4aIagi0bhZowkgD","ja5HFaIxVEtbZoTklNXfZ","vnzxfoqb6aqbrqy247uonqo","jjlv4wd30bvf0r680o9ptbi","kok8aerdrzko8v4i6w6qtjx","hr8ruqfxd2miwldyehzz5zy","criy8usqjrguecufwb3k8z2","3x9f9wclumzxc23dzgraepy","sma2hkp8hvq9urmtk94qqwq","4bcvwahaynsox941d8dimxw","8u19znq05xj50ptse0fq8nj","hbcft05imtwxxtwk52nij1n","2vmt81onv3jf06ejwfusj30","npuhs4xvm0sa31rz2gcuff3","mwt2mrjm58oa3q2osoqwd64","yjnf5fuac95jbdmjj923hyh","17p3nbv4rvga83hhsz2idzp","8r1egy8mz3lp7ud9p8kcg8z","5gf8xb68r1y0kxumkvvmuez","d92qhaqtfbt7e4eximdnbht","r25bm5nuug9krur6ddqearm"],"parent":null,"data":{},"body":"\nMy personal knowledge cache using [Dendron](https://www.dendron.so)\n\n## History\nIt was during my first job, at the start-up company called PixelShift.AI, that I acquired most prominent skill as a software engineer-the ability to read source code. It opened up a new way of learning and my knowledge expanded rapidly ever since. Learning new things is thriving but noting them down cogently and organized is hard. I often found myself forget the context few month later, making the notes completely intelligible. Additionally, some notes need frequent update as my previous understanding could be parochial, antiquated or even erroneous.\n\nIn desperate attempt to facilitate the noting/updating experience, I came across [Dendron](https://www.dendron.so) and found it surprisingly congenial to my personal need. With it, I have gradually grown the habit of caching, linking back and extending my knowledge base.\n\n## Disclaimer\nThe notes are collections of information I found along the journey. I use backquote to denote sources, but I am likely to miss some references, so apology in advance. Also, they are my personal understandings, usually added when I first encounter the topic and will be updated only when I come across it again, so some of them could be incomplete or wrong."},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.86.1","enableFullHierarchyNoteTitle":false,"enableHandlebarTemplates":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"enableSiteLastModified":true,"siteRootDir":"docs","enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"writeStubs":false,"seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enablePrettyLinks":true,"assetsPrefix":"/my-personal-knowledge-cache","siteUrl":"https://ankbzpx.github.io","enableTaskNotes":true,"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}